|<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Subasta en Vivo</title>
    <style>
        /* ESTILOS BASE DEL DASHBOARD (INTACTO) */
        body { font-family: Arial, sans-serif; background: #111; color: white; text-align: center; margin:0; padding:0; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; }
        h1 { margin:20px 0; }
        ul { list-style: none; padding: 0; }
        li { margin: 5px 0; font-size: 18px; }
        .totales { margin-top: 10px; font-weight: bold; font-size: 16px; }
        h2 { background: rgba(255,255,255,0.15); padding: 4px 8px; border-radius: 5px; display: inline-block; margin-bottom: 10px; font-size: 18px; }
        button { margin: 5px; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        .start { background: green; color: white; }
        .stop { background: red; color: white; }
        #logDonaciones { background: #333; color: #ccc; width: 740px; height: 150px; overflow-y: auto; margin: 20px auto; padding: 10px; border-radius: 10px; text-align: left; font-family: monospace; }
        
        /* CONTENEDORES PRINCIPALES (MODO DASHBOARD: TRES COLUMNAS) (INTACTO) */
        #ganadores, #participantes, #controles-group { margin: 20px; padding: 20px; border-radius: 10px; display: inline-block; vertical-align: top; }
        #ganadores { background: #2c3e50; width: 350px; height: 400px; overflow-y: auto; }
        #participantes { background: #27ae60; width: 350px; height: 400px; overflow-y: auto; }
        #controles-group { width: 300px; padding: 0; margin: 20px 0 0 0; display: inline-block; vertical-align: top; }
        #controles { background: #8e44ad; width: 300px; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        #tiempoBox { background: #e67e22; width: 300px; height: 120px; display:flex; flex-direction:column; justify-content:center; align-items:center; font-size:20px; font-weight:bold; border-radius: 10px; }

        /* WIDGET MODE (ESTILOS FINALES PARA EL OVERLAY) (INTACTO) */
        .widget-mode body { background: transparent !important;; min-height: 0; display: block; overflow: hidden; }
        
        /* OCULTAR TODO LO QUE NO SEA EL WIDGET (INTACTO) */
        .widget-mode #main-dashboard-content { display: none !important; }
        .widget-mode #logDonaciones { display: none !important; } 
        .widget-mode #widget-container {
            
    /* Usamos !important para anular el 'display: none' del CSS general. */
    display: flex !important; 
    
    /* Adaptar al tamaÃ±o de la ventana del Widget */
    position: absolute; 
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    margin: 0;
}

        /* ESTILOS DEL CONTENEDOR PRINCIPAL DEL WIDGET (INTACTO) */
        #widget-container {
            display: none; /* Por defecto oculto */
            flex-direction: column;
            width: 360px; /* Ancho fijo para el widget */
            margin: 0 auto;
            background: linear-gradient(180deg, #0a0a0a 0%, #0f1626 100%);
            border-radius: 10px;
            overflow: hidden;
            border: 4px solid #FFD700; /* Borde grueso, color oro */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); /* Brillo dorado opcional */ 
        }

        /* ESTILOS INTERNOS DEL WIDGET (INTACTO) */
        #tiempoBox-widget { background: #1a1a1a; width: 100%; padding: 10px 0; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px 8px 0 0;border-bottom: 2px solid #FFD700; }
        #tiempoRestante-widget { font-size: 2.5em; color: #FFD700; font-weight: bold; text-shadow: 0 0 8px rgba(255, 215, 0, 0.7); }
        #subtext-widget { font-size: 14px; color: #ccc; margin-top: 5px; }
       .snipe-alert #tiempoRestante-widget {  color: #FF4D4D !important; /* ROJO */ text-shadow: 0 0 15px rgba(255, 77, 77, 1) !important; /* Sombra ROJA mÃ¡s fuerte */}
        .snipe-alert #subtext-widget {  color: #FF4D4D !important; /* ROJO */}


        #participantes-widget { background: #1c2b3e; width: 100%; height: auto; min-height: 200px; padding: 10px; border-radius: 0 0 8px 8px;box-sizing: border-box; }
        #participantes-widget h2, #participantes-widget .totales { display: none; }
        #listaParticipantes-widget { padding: 0; margin: 0; list-style: none; }
        #listaParticipantes-widget li { display: flex; align-items: center; justify-content: space-between; background: #2a3d5e; margin-bottom: 8px; padding: 10px 15px; border-radius: 12px; font-size: 16px; font-weight: bold; border: 2px solid #555; box-shadow: 0 4px 8px rgba(0,0,0,0.4); }
        #listaParticipantes-widget li .coins { color: #ffd700; font-size: 1.1em; margin-left: 10px; display: flex; align-items: center; }
        /* #listaParticipantes-widget li .coins::before { content: 'ğŸª™'; margin-right: 5px; font-size: 0.9em; } */

        /* --- INICIO: ESTILOS CORRECTOS PARA EL RANKING DEL WIDGET --- */
.rank-icon { 
    font-size: 1.2em; 
    color: #FFD700; /* NÃºmero de ranking en color oro */
    margin-right: 10px; 
    min-width: 25px; 
    height: 25px;
    text-align: center; 
    background: #3a4d70; /* Fondo circular azul oscuro */
    border-radius: 50%; /* Esto lo hace un cÃ­rculo */
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #FFD700; /* Borde dorado */
    box-sizing: border-box; /* Para que el padding no rompa el tamaÃ±o */
}
.user-info { 
    display: flex; 
    align-items: center; 
    flex-grow: 1; 
    overflow: hidden; 
}
.user-avatar { 
    width: 30px; 
    height: 30px; 
    border-radius: 50%; 
    overflow: hidden; 
    margin-right: 10px; 
    border: 2px solid #fff; 
}
.user-avatar img { 
    width: 100%; 
    height: 100%; 
    object-fit: cover; 
}
.username { 
    color: #ecf0f1; 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis; 
    max-width: 150px; 
}
/* --- FIN: ESTILOS CORRECTOS --- */
#winner-popup {
    display: none; /* Oculto por defecto */
    position: fixed; /* Overlay que cubre todo */
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85); /* Fondo oscuro semitransparente */
    z-index: 100;
    /* Usamos flex para centrar el contenido */
    justify-content: center;
    align-items: center;
    font-family: Arial, sans-serif;
    /* Para la animaciÃ³n de entrada/salida */
    opacity: 0;
    transition: opacity 0.5s ease;
}

#winner-content {
    background: linear-gradient(145deg, #1f2a3a, #1a2330);
    border: 4px solid #FFD700; /* Borde Dorado */
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    color: white;
    box-shadow: 0 0 30px rgba(255, 215, 0, 0.7); /* Brillo Dorado */
    /* AnimaciÃ³n "pop" de entrada */
    transform: scale(0.7);
    transition: transform 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28);
}

#winner-content h2 {
    margin: 0;
    font-size: 24px;
    color: #eee;
}

#winner-avatar {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    border: 4px solid #FFD700;
    margin: 20px auto;
    overflow: hidden;
}
#winner-avatar img { width: 100%; height: 100%; object-fit: cover; }

#winner-name {
    font-size: 48px;
    color: #FFD700;
    margin: 10px 0;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}

#winner-content p {
    font-size: 20px;
    color: #ccc;
    margin: 10px 0;
}
#winner-content p span {
    color: #fff;
    font-weight: bold;
}

.felicidades {
    font-size: 28px !important;
    font-weight: bold;
    color: #FFD700 !important;
}
    </style>
</head>
<body>
    
    <div id="main-dashboard-content" style="display: flex; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 1200px;">
        <h1>âš¡ Subasta en Vivo âš¡</h1>
        
        <div id="ganadores"><h2>ğŸ† Ganadores de Rondas</h2><ul id="listaGanadores"></ul></div>
        <div id="participantes"><h2>ğŸ‘¥ Participantes (Ronda Actual)</h2><ul id="listaParticipantes"></ul>
            <div class="totales">Total participantes: <span id="totalParticipantes">0</span></div>
            <div class="totales">Diamantes donados: <span id="totalDiamantes">0</span></div>
        </div>

        <div id="controles-group">
            <div id="controles">
                <h2>ğŸ® Controles</h2>
                <label for="tiktokUser">ğŸ‘¤ TikTok User:</label><br>
<input type="text" id="tiktokUser" placeholder="@usuario" style="width: 90%; margin-bottom: 15px; padding: 5px;"><br>

<label for="streamerMasterId">ğŸ”‘ ID Ãšnico del Streamer:</label><br>
<input type="text" id="streamerMasterId" value="" placeholder="Ej: MiNombreDeUsuario" style="width: 90%; margin-bottom: 15px; padding: 5px;"><br>

<div class="subcuadro">
Â  Â  <div class="subcuadro">
Â  Â  Â  Â  <label for="tiempo">â± Tiempo inicial (segundos):</label><br>
Â  Â  Â  Â  <input type="number" id="tiempo" value="200"><br><br>
Â  Â  Â  Â  
Â  Â  Â  Â  <label for="tiempoSnipe">Tiempo de snipe (segundos):</label>
Â  Â  Â  Â  <input type="number" id="tiempoSnipe" value="15" min="0">
Â  Â  Â  Â  
        Â  Â  Â  Â  <button class="start" onclick="iniciar()">Iniciar</button>
Â  Â  Â  Â  <button onclick="pausar()">Pausar</button>
Â  Â  Â  Â  <button class="stop" onclick="finalizar()">Finalizar</button> 
        <button onclick="restart()">Restart</button>
Â  Â  Â  Â  <button style="background:#2ecc71; color:white;" onclick="abrirWidget()">Ver Widget</button>
Â  Â  Â  Â  <button onclick="simularRegalo()" style="background-color: #007bff; color: white; margin-top: 5px;">Simular Regalo</button>
        Â  Â  </div>
</div>
            <div id="tiempoBox"><h2>â³ Tiempo Restante</h2><div id="tiempoRestante" style="font-size: 2.5em;">0</div></div>
        </div>

        <div id="logDonaciones"><strong>ğŸ“ Historial de Eventos:</strong></div>
    </div> 

    <div id="widget-container">
        
        <div id="tiempoBox-widget">
            <div id="tiempoRestante-widget">00:00</div>
            <div id="subtext-widget">El sorteo/subasta termina en</div>
        </div>
        <div id="participantes-widget">
            <ul id="listaParticipantes-widget"></ul>
        </div>
        
    </div>
    <div id="winner-popup" style="display: none;">
        </div>
    
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

    <script>
        // 1. FUNCIÃ“N DE UTILIDAD: Leer un parÃ¡metro de la URL
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        };

        // 2. INICIALIZACIÃ“N DE ID Y CONEXIÃ“N
// ğŸ›‘ CRÃTICO: Definir la variable global para que el scope funcione correctamente.
let streamerId = ""; 

const socket = io("https://tiktok-servidor.onrender.com");

        // 3. VARIABLES GLOBALES
        const listaParticipantesEl = document.getElementById('listaParticipantes');
        const listaGanadoresEl = document.getElementById('listaGanadores');
        const tiempoRestanteEl = document.getElementById('tiempoRestante');
        const logDonacionesEl = document.getElementById('logDonaciones');
        
        let tiempoActual = 0;
        let intervalo = null;
        let participantes = [];
        let ganadoresHistorial = [];
        let isPaused = false; 
        let snipeActivado = false; 
        let subastaActiva = false;
        let isSnipeModeVisual = false;

        // 4. LÃ“GICA DE PROTECCIÃ“N (Mantenemos tu lÃ³gica de cachÃ©)
        const processedGiftIds = new Set();
        setInterval(() => {
          processedGiftIds.clear();
          // console.log("Limpiando cachÃ© de IDs de regalos procesados.");
        }, 60000); 

        // 5. FunciÃ³n para abrir el Widget (Asegura que la URL tenga el ID)
        function abrirWidget() {
    const streamerId = getCurrentStreamerId();
    if (!streamerId) { alert("Introduce tu ID de Streamer antes de abrir el Widget."); return; }
    const widgetUrl = `https://tiktok-servidor.onrender.com/?mode=widget&streamerId=${encodeURIComponent(streamerId)}`;
    if (window.electronAPI && window.electronAPI.abrirWidgetVentana) {
        window.electronAPI.abrirWidgetVentana(widgetUrl);
    } else {
        window.open(widgetUrl, 'WidgetTikTok', 'width=350,height=600');
    }
}
        

       // 6. ConfiguraciÃ³n Inicial del Dashboard
document.addEventListener('DOMContentLoaded', () => {
    
    // 1. DetecciÃ³n de modo
    const isWidgetMode = getUrlParameter('mode') === 'widget'; 
    
    let initialStreamerId;

    if (isWidgetMode) {
        // ğŸ›‘ WIDGET: Debe leer el ID de la URL usando el nombre de parÃ¡metro correcto.
        initialStreamerId = getUrlParameter('streamerId'); // ğŸ›‘ Â¡CORREGIDO!
    } else {
        // DASHBOARD: Debe leer el ID del input.
        initialStreamerId = getCurrentStreamerId();
    }
    
    // 2. LÃ³gica de uniÃ³n a la sala
    if (initialStreamerId) { 
        // ğŸ›‘ CRÃTICO: Actualizar la variable global 'streamerId' aquÃ­ para que las demÃ¡s funciones la usen
        streamerId = initialStreamerId; 
        
        socket.emit("join_room", streamerId); 

        if (isWidgetMode) {
            document.body.classList.add('widget-mode');
            console.log(`WIDGET unido a la sala: ${streamerId}`);
        } else {
            // ... (resto del cÃ³digo del Dashboard) ...
        }
    } else {
        console.log("âš ï¸ ERROR: No se ha definido un ID de streamer. Funcionalidad deshabilitada.");
    }
});

        // ğŸ›‘ AquÃ­ va el resto del JavaScript (la Parte 2 que enviaste antes) ğŸ›‘

// ...

        // --- FUNCIONES DE UTILIDAD ---
        function formatTime(totalSeconds) {
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// Nota: La funciÃ³n actualizarParticipantesUI original que enviaste estaba duplicada
// y usaba un mix de estilos. Usaremos la versiÃ³n que incluye el ranking de widget.
// Se recomienda mantener una Ãºnica funciÃ³n de UI mÃ¡s limpia y flexible.
function actualizarParticipantesUI() {
    participantes.sort((a, b) => parseInt(b.cantidad) - parseInt(a.cantidad));

    const isWidgetMode = document.body.classList.contains('widget-mode');

    // 1. Apuntamos a las listas correctas
    const listaDashboardEl = document.getElementById('listaParticipantes');
    const listaWidgetEl = document.getElementById('listaParticipantes-widget'); 

    // 2. Limpiamos ambas listas
    if (listaDashboardEl) listaDashboardEl.innerHTML = "";
    if (listaWidgetEl) listaWidgetEl.innerHTML = "";

    let totalDiamantes = 0;

    participantes.forEach((p, index) => {
        const rango = index + 1;
        const avatarUrl = p.avatar_url || 'https://via.placeholder.com/30/555/FFFFFF?text=A';

        // --- Formato de Dashboard (Lista simple) ---
        if (listaDashboardEl && !isWidgetMode) {
            const liDashboard = document.createElement("li");
            liDashboard.textContent = `${rango}. ${p.usuario} - ${p.cantidad} ğŸ’`;
            listaDashboardEl.appendChild(liDashboard);
        }

        // --- Formato de Widget (Top 5 con ranking) ---
        if (index < 5 && listaWidgetEl) {
            const liWidget = document.createElement("li");
            
            liWidget.innerHTML = `
                <div class="rank-icon">${rango}</div>
                <div class="user-info">
                    <div class="user-avatar"><img src="${avatarUrl}" alt="Avatar"></div>
                    <span class="username">${p.usuario}</span>
                </div>
                <span class="coins">${p.cantidad} ğŸª™</span>
            `;
            listaWidgetEl.appendChild(liWidget);
        }
        
        totalDiamantes += parseInt(p.cantidad || 0);
    });
    
    // Solo actualizamos totales en el Dashboard
    if (!isWidgetMode) {
        document.querySelector('#totalParticipantes').textContent = participantes.length;
        document.querySelector('#totalDiamantes').textContent = totalDiamantes;
    }
}

function actualizarGanadoresUI() {
    const listaGanadoresEl = document.getElementById('listaGanadores');
    listaGanadoresEl.innerHTML = "";
    ganadoresHistorial.forEach(g => {
        const li = document.createElement('li');
        li.textContent = `ğŸ† ${g.usuario} - ${g.cantidad} ğŸ’`;
        listaGanadoresEl.appendChild(li);
    });
}
// ---------------------------------------------


// --- LÃ“GICA DEL TEMPORIZADOR (DASHBOARD MAESTRO) ---
function iniciarTimerLogic() {
    // ğŸ›‘ CRÃTICO: Usar la variable global 'streamerId' que ya se inicializÃ³ en DOMContentLoaded
    const timerStreamerId = streamerId; // Usamos un nombre local claro
    
    if (!timerStreamerId) return; // Si el ID global no estÃ¡ seteado, salir.

    if (intervalo) {
        clearInterval(intervalo);
    }
    
    if (tiempoActual <= 0) {
        // Asumiendo que el ID del input de tiempo es "tiempo"
        const tiempoInicialInput = document.getElementById("tiempo"); 
        // CRÃTICO: Lee el valor del input y asigna un default si estÃ¡ vacÃ­o
        tiempoActual = parseInt(tiempoInicialInput.value) || 200; 
    }
    
    if (isPaused) {
        return; 
    }

    intervalo = setInterval(() => {
        if (!isPaused) {
            tiempoActual--;
            
            const tiempoRestanteEl = document.getElementById('tiempoRestante');
            if (tiempoRestanteEl) {
                tiempoRestanteEl.textContent = formatTime(tiempoActual); 
            }

            // Sincronizar el tiempo con el servidor para el Widget
            socket.emit('sync_time', { 
                time: tiempoActual, 
                streamerId: timerStreamerId // Usamos el ID validado/global
            }); 

            if (tiempoActual <= 0) {
                clearInterval(intervalo);
                intervalo = null;
                terminarTiempo(); 
            }
        }
    }, 1000); 
}

function iniciar() {
    // 1. OBTENER Y VALIDAR EL ID DEL STREAMER (Â¡CRÃTICO!)
    const currentStreamerId = getCurrentStreamerId(); 
    
    if (!currentStreamerId) {
        alert("Â¡Alerta! Por favor, introduce tu ID de Streamer antes de iniciar.");
        return;
    }
    
    // 2. VERIFICAR QUE NO ESTAMOS EN MODO WIDGET
    if (document.body.classList.contains('widget-mode')) {
        return;
    }

    // 3. INICIAR LA LÃ“GICA
    snipeActivado = false;
    subastaActiva = true;
    logDonacionesEl.innerHTML += `<p style="color: yellow;">â–¶ï¸ Iniciando ronda...</p>`;
    
    // 4. Avisar al servidor
    socket.emit("iniciar_subasta", { streamerId: currentStreamerId }); 
    
    isPaused = false;
    tiempoActual = 0; // Se inicializa a 0 para que iniciarTimerLogic lo lea del input
    
    // 5. Iniciar el bucle de sincronizaciÃ³n de tiempo (ESTO SETEA tiempoActual)
    iniciarTimerLogic(); 

    // ğŸ’¡ AÃ‘ADIR: SincronizaciÃ³n inmediata para que el Widget arranque a la vez
    if (tiempoActual > 0) {
        socket.emit('sync_time', { 
            time: tiempoActual, 
            streamerId: currentStreamerId // Usa el ID validado para el emit
        }); 
    }
}
function pausar() {
    // ğŸ›‘ CAMBIO: Obtener el ID del input, pero solo si es necesario
    const currentStreamerId = getCurrentStreamerId(); 

    if (!document.body.classList.contains('widget-mode')) {
        isPaused = !isPaused;
        if (isPaused) {
            if (intervalo) clearInterval(intervalo);
            intervalo = null;
            logDonacionesEl.innerHTML += `<p style="color: orange;">â¸ï¸ Temporizador en pausa.</p>`;
        } else {
            // Si reanudamos, volvemos a llamar a la lÃ³gica para reestablecer el intervalo
            iniciarTimerLogic(); 
            logDonacionesEl.innerHTML += `<p style="color: green;">â–¶ï¸ Temporizador reanudado.</p>`;
        }
    }
}

function finalizar() {
    // ğŸ›‘ CRÃTICO: Leer el ID al principio
    const streamerId = getCurrentStreamerId(); 
    
    if (!document.body.classList.contains('widget-mode') && streamerId) {
        if (intervalo) { 
            clearInterval(intervalo); 
            intervalo = null; 
        }
        
        tiempoActual = 0;
        // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
        socket.emit('sync_time', { time: 0, streamerId: streamerId }); 
        if (document.getElementById('tiempoRestante')) {
            document.getElementById('tiempoRestante').textContent = formatTime(0);
        }
        
        // Avisar al servidor que se finalizÃ³
        socket.emit('finalizar_subasta', { streamerId: streamerId }); 

        logDonacionesEl.innerHTML += `<p style="color: red;">â¹ï¸ Ronda finalizada manualmente.</p>`;

        // LÃ³gica de ganador
        if (participantes.length > 0) {
            participantes.sort((a, b) => parseInt(b.cantidad) - parseInt(a.cantidad));
            const ganador = participantes[0];
            ganadoresHistorial.unshift(ganador); 
            logDonacionesEl.innerHTML += `<p style="color: gold;">ğŸ† Â¡Ganador guardado: ${ganador.usuario} con ${ganador.cantidad} diamantes!</p>`;
            actualizarGanadoresUI();
            
            // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
            socket.emit("anunciar_ganador", { ...ganador, streamerId: streamerId });
        } else {
            logDonacionesEl.innerHTML += `<p style="color: gray;">â„¹ï¸ No hubo participantes en esta ronda.</p>`;
        }

        // Limpiar listas y apagar interruptor
        subastaActiva = false;
        participantes = []; 
        actualizarParticipantesUI(); 
        // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
        socket.emit("limpiar_listas", { streamerId: streamerId });
    }
}

function restart() {
    // ğŸ›‘ CRÃTICO: Leer el ID al principio
    const streamerId = getCurrentStreamerId();
    
    if (!document.body.classList.contains('widget-mode') && streamerId) { 
        // Llama a finalizar, lo que limpia listas y detiene el tiempo
        finalizar(); 

        // Limpia el historial de ganadores tambiÃ©n
        ganadoresHistorial = [];
        actualizarGanadoresUI();
        
        snipeActivado = false;
        
        logDonacionesEl.innerHTML = '<strong>ğŸ“ Historial de Eventos:</strong><p style="color: cyan;">ğŸ”„ Sistema reiniciado. Listo para una nueva subasta.</p>';
        
        if (document.getElementById('tiempoRestante')) 
            document.getElementById('tiempoRestante').textContent = formatTime(0);
        
        // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
        socket.emit('sync_time', { time: 0, streamerId: streamerId }); 
        // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
        socket.emit("limpiar_listas", { streamerId: streamerId });
    }
}

// Nota: La funciÃ³n terminarTiempo se usa internamente por iniciarTimerLogic()
function terminarTiempo() {
    // ğŸ›‘ CRÃTICO: Leer el ID al principio
    const streamerId = getCurrentStreamerId();
    
    if (!document.body.classList.contains('widget-mode') && streamerId) { 
        // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
        socket.emit("restaurar_widget", { streamerId: streamerId });

        if (intervalo) { 
            clearInterval(intervalo); 
            intervalo = null; 
        }

        // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
        socket.emit('finalizar_subasta', { streamerId: streamerId });
        // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
        socket.emit('sync_time', { time: 0, streamerId: streamerId }); 
        tiempoActual = 0; 
        if (document.getElementById('tiempoRestante')) {
            document.getElementById('tiempoRestante').textContent = formatTime(0);
        }

        const tiempoSnipe = parseInt(document.getElementById("tiempoSnipe").value) || 0;

        if (!snipeActivado && tiempoSnipe > 0) {
            // A) AÃšN QUEDA EL SNIPE
            snipeActivado = true;
            logDonacionesEl.innerHTML += `<p style="color: yellow;">âš¡ Modo SNIPE activado (${tiempoSnipe}s extra)</p>`;

            // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
            socket.emit("iniciar_snipe_cliente", { time: tiempoSnipe, streamerId: streamerId });
            // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
            socket.emit("activar_alerta_snipe_visual", { streamerId: streamerId });

            tiempoActual = tiempoSnipe;
            iniciarTimerLogic(); // Inicia el timer de nuevo con el tiempo Snipe
        } else {
            // B) NO HAY SNIPE (LÃ³gica de finalizaciÃ³n/ganador)
            // ... (el resto de la lÃ³gica permanece igual) ...
            
            if (participantes.length > 0) {
                // ... (lÃ³gica de ganador) ...
                // ğŸ›‘ CRÃTICO: Usamos el ID reciÃ©n leÃ­do
                socket.emit("anunciar_ganador", { ...ganador, streamerId: streamerId });
            } else {
                logDonacionesEl.innerHTML += `<p style="color: gray;">â„¹ï¸ No hubo participantes en esta ronda.</p>`;
            }
        }
    }
}

function simularRegalo() {
    // ğŸ›‘ CRÃTICO: Leer el ID al principio
    const streamerId = getCurrentStreamerId();
    
    if (!streamerId) {
        alert("Introduce un ID de Streamer para simular un regalo.");
        return;
    }
    
    // ... cÃ³digo de generaciÃ³n de usuario/cantidad ...
    const randomUser = 'TestUser' + Math.floor(Math.random() * 100);
    const randomAmount = Math.floor(Math.random() * 100) + 1;
    const giftName = 'Rosa';
    
    // CRÃTICA: Usamos el ID reciÃ©n leÃ­do
    socket.emit("new_gift", { 
        usuario: randomUser,
        cantidad: randomAmount, 
        regalo: giftName,
        avatar_url: `https://via.placeholder.com/30/555/FFFFFF?text=${randomUser.charAt(0)}`,
        streamerId: streamerId
    });
}
// --- FUNCIÃ“N AUXILIAR ---
function getCurrentStreamerId() {
    const streamerMasterInput = document.getElementById('streamerMasterId');
    return streamerMasterInput ? streamerMasterInput.value.trim() : ""; 
}
// ğŸ‘† FIN DE FUNCIÃ“N SIMULAR REGALO CORREGIDA ğŸ‘†

// ------------------------------------------------------------------
// El Widget recibe la hora (Esta funciÃ³n tambiÃ©n debe ser modificada)
// ğŸ›‘ CORRECCIÃ“N: El servidor ahora envÃ­a un objeto, no solo el tiempo ğŸ›‘
socket.on('update_time', (data) => {
  if (!data || typeof data.time === 'undefined') return;
  if (!document.body.classList.contains('widget-mode')) return;
  tiempoActual = data.time;
  const formatted = formatTime(data.time);
  const el = document.getElementById('tiempoRestante-widget');
  if (el) el.textContent = formatted;
  // (resto de visual snipe)
});

// ===============================================
// ğŸ CONEXIÃ“N A LA API DE TIKFINITY (localmente)
// ===============================================
const tikfinityWS = new WebSocket("ws://localhost:21213/");
tikfinityWS.onopen = () => console.log("âœ… Conectado a TikFinity WebSocket");
tikfinityWS.onerror = err => console.error("âŒ Error TikFinity WS:", err);

// ===============================================
// ğŸ CUANDO LLEGUE UN EVENTO DE TIKTOK
// ===============================================
tikfinityWS.onmessage = (msg) => {
    const data = JSON.parse(msg.data);
    if (!data || !data.event) return;

    if (data.event === "gift") {
        const gift = data.data;
        const totalDiamonds = gift.diamondCount || gift.repeatCount || 1;
        const streamerId = getCurrentStreamerId(); // usa el input donde el streamer pone su ID

        if (!streamerId) {
            console.warn("âš ï¸ No se encontrÃ³ streamerId, no se enviarÃ¡ el regalo");
            return;
        }

        // Armar el payload
        const payload = {
            usuario: gift.uniqueId || gift.nickname || "Anon",
            cantidad: totalDiamonds,
            regalo: gift.giftName || "Regalo",
            avatar_url: gift.profilePictureUrl || null,
            streamerId: streamerId
        };

        // Enviar al servidor (Render)
        socket.emit("new_gift", payload);
        console.log("ğŸ Enviado al servidor new_gift:", payload);
    }
};

// ===============================================
// ğŸ NUEVOS REGALOS
// ===============================================
socket.on("new_gift", (giftData) => {
    const { userId, nickname, profilePictureUrl, diamondCount, streamerId } = giftData;
    const cantidadDelRegalo = diamondCount || 0;

    // Si este widget no pertenece a este streamer, ignorar el evento
    if (streamerId !== giftData.streamerId) return;

    // Buscar si el usuario ya existe en la lista
    let participante = participantes.find(p => p.userId === userId);

    if (participante) {
        // Si ya existe, sumar a su cantidad
        participante.cantidad = (parseInt(participante.cantidad) + cantidadDelRegalo).toString();
    } else {
        // Si es nuevo, agregarlo
        participantes.push({
            userId,
            nickname,
            profilePictureUrl,
            cantidad: cantidadDelRegalo.toString()
        });
    }

    // ğŸ”¢ Ordenar el ranking por cantidad donada
    participantes.sort((a, b) => parseInt(b.cantidad) - parseInt(a.cantidad));

    // ğŸ“¢ Actualizar el ranking en pantalla
    actualizarListaParticipantes();

    // ğŸ•’ Si el modo snipe estÃ¡ activo (solo para el dashboard, no widgets)
    if (!document.body.classList.contains('widget-mode') && snipeActivado && cantidadDelRegalo > 0 && streamerId) {
        const tiempoSnipe = parseInt(document.getElementById("tiempoSnipe").value) || 0;

        if (tiempoActual <= tiempoSnipe) {
            tiempoActual = tiempoSnipe;

            // ğŸ”„ Avisar al servidor que se sincronice el tiempo
            socket.emit('sync_time', { time: tiempoActual, streamerId: streamerId });

            // Log visual
            logDonacionesEl.innerHTML += `<p style="color: red;">â° SNIPE: Tiempo restablecido a ${tiempoSnipe}s!</p>`;
        }
    }

    // âœ¨ Log visual de donaciÃ³n
    if (logDonacionesEl) {
        logDonacionesEl.innerHTML += `<p>ğŸ’ ${nickname} donÃ³ ${cantidadDelRegalo}!</p>`;
    }
});
// ===============================================
// â±ï¸ SINCRONIZACIÃ“N DE TIEMPO
// ===============================================
socket.on("sync_time", (data) => {
  if (!data || !data.streamerId) return;
  io.to(data.streamerId).emit("update_time", { time: data.time });
});
    // ğŸ“¢ Â¡LÃNEA DE SINCRONIZACIÃ“N!
    // Enviamos la lista final (ordenada y sumada) al servidor
    // ğŸ›‘ CORRECCIÃ“N: Incluir streamerId
    if (streamerId) {
        socket.emit('sync_participantes', { participantes: participantes, streamerId: streamerId }); 
    }

    // Ahora sÃ­, actualiza la UI con la lista ya ordenada
    actualizarParticipantesUI();

// ===============================
// ğŸ§¹ Limpiar listas cuando el servidor lo indique
// ===============================
socket.on("limpiar_listas_clientes", () => {
    console.log("ğŸ§¹ Recibido comando para limpiar lista local.");
    participantes = [];
    actualizarParticipantesUI();
    subastaActiva = false;
    isSnipeModeVisual = false; // Reset visual snipe
    document.body.classList.remove('snipe-alert');
    const subtextElWidget = document.getElementById('subtext-widget');
    if (subtextElWidget) subtextElWidget.textContent = "El sorteo/subasta termina en";
    console.log("CLIENTE: Interruptor APAGADO.");
});


/* ================================================== */
/* ğŸ‘‘ BLOQUE ÃšNICO PARA MOSTRAR GANADOR (Dashboard + Widget) ğŸ‘‘ */
/* ğŸ›‘ CORRECCIÃ“N: El servidor ahora envÃ­a un objeto que contiene 'streamerId' ğŸ›‘ */
/* ================================================== */
socket.on("anunciar_ganador", (data) => {
    if (typeof data !== 'object' || data === null || !data.usuario) {
        console.log("âš ï¸ No hubo ganador en esta ronda.");
        return;
    }
    const ganador = data; // Data ahora contiene los datos del ganador mÃ¡s el streamerId
    const isWidget = document.body.classList.contains('widget-mode');

    if (!isWidget) {
        // ===========================
        // ğŸ–¥ï¸ MOSTRAR EN DASHBOARD
        // ===========================
        console.log("ğŸ¬ Mostrando popup de ganador en el Dashboard:", ganador.usuario);

        const popup = document.getElementById('winner-popup');
        const nameEl = document.getElementById('winner-name');
        const amountEl = document.getElementById('winner-amount');
        const avatarImgEl = document.getElementById('winner-avatar').querySelector('img');
        const contentEl = document.getElementById('winner-content');

        nameEl.textContent = ganador.usuario;
        amountEl.textContent = ganador.cantidad + " ğŸª™";
        avatarImgEl.src = ganador.avatar_url || 'https://via.placeholder.com/100/555/FFFFFF?text=A';

        requestAnimationFrame(() => {
            popup.style.display = 'flex';
            requestAnimationFrame(() => {
                popup.style.opacity = '1';
                contentEl.style.transform = 'scale(1)';
            });
        });

        setTimeout(() => {
            popup.style.opacity = '0';
            contentEl.style.transform = 'scale(0.7)';
            setTimeout(() => {
                popup.style.display = 'none';
                // ğŸ›‘ CORRECCIÃ“N: El Dashboard limpia localmente, pero avisa al servidor con ID
                if (streamerId) {
                    socket.emit("limpiar_listas", { streamerId: streamerId });
                }
            }, 500);
        }, 10000);

    } else {
        // ===========================
        // ğŸ“º MOSTRAR EN WIDGET (TIKTOK STUDIO)
        // ===========================
        console.log("ğŸ‘‘ Mostrando ganador en el widget:", ganador.usuario);

        // 1ï¸âƒ£ Limpiar el ranking localmente (el servidor enviarÃ¡ la orden de limpieza global)
        const rankingList = document.getElementById("listaParticipantes-widget");
        if (rankingList) rankingList.innerHTML = "";
        participantes = [];

        // 2ï¸âƒ£ Crear un banner flotante encima del widget
        const container = document.createElement("div");
        container.id = "widget-winner-popup";
        container.style.position = "fixed";
        container.style.top = "10%";
        container.style.left = "50%";
        container.style.transform = "translateX(-50%)";
        container.style.zIndex = "9999";
        container.style.background = "rgba(0,0,0,0.85)";
        container.style.color = "#fff";
        container.style.padding = "25px 50px";
        container.style.borderRadius = "20px";
        container.style.textAlign = "center";
        container.style.fontSize = "1.6em";
        container.style.backdropFilter = "blur(6px)";
        container.style.boxShadow = "0 0 20px rgba(255, 215, 0, 0.8)";
        container.style.animation = "popIn 0.4s ease";

        container.innerHTML = `
            <div style="display:flex; align-items:center; justify-content:center; gap:15px;">
                <img src="${ganador.avatar_url || 'https://via.placeholder.com/60/000/fff?text=?'}"
                    style="width:60px; height:60px; border-radius:50%; border:3px solid gold;">
                <div>
                    <div style="font-weight:bold; color:#FFD700;">ğŸ† Â¡GANADOR DE LA SUBASTA! ğŸ†</div>
                    <div>${ganador.usuario}</div>
                    <div style="font-size:1.2em;">${ganador.cantidad} ğŸª™</div>
                </div>
            </div>
        `;

        document.body.appendChild(container);

        // 3ï¸âƒ£ Quitar banner despuÃ©s de 10 segundos
        setTimeout(() => {
            container.style.transition = "opacity 0.5s ease";
            container.style.opacity = "0";
            setTimeout(() => {
                container.remove();
                // âœ… CORRECCIÃ“N FINAL: Se elimina la llamada a limpiar_listas desde el Widget. 
                // La limpieza final la harÃ¡ el Dashboard/Maestro.
            }, 500);
        }, 10000);
    }
});

/* AnimaciÃ³n del popup */
const style = document.createElement("style");
style.innerHTML = `
@keyframes popIn {
  0% { transform: scale(0.8); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}`;
document.head.appendChild(style);
// Widget (Cliente) - RecepciÃ³n de eventos del Dashboard
socket.on("activar_alerta_snipe_visual", () => {
    // Cuando el Dashboard dice que el Snipe comenzÃ³, activamos la bandera visual
    isSnipeModeVisual = true;
});

socket.on('finalizar_subasta', () => {
    // Cuando la subasta termina, la bandera se apaga (ademÃ¡s de la limpieza)
    isSnipeModeVisual = false; 
    
    // Y hacemos la limpieza final del cuerpo para volver a amarillo
    document.body.classList.remove('snipe-alert');
    const subtextElWidget = document.getElementById('subtext-widget');
    if (subtextElWidget) subtextElWidget.textContent = "El sorteo/subasta termina en";
});
    </script>
</body>
</html>

